#!/bin/sh
# Reference: https://tools.ietf.org/html/rfc5092
#            https://tools.ietf.org/html/rfc3501

usage() {
    cat >&2 << EOF
Usage: $(basename "$0") [-s server] [-p port] [-P password] [-n N] [-h] email

Options:
    -s: Server address of email provider.
        For the following email providers this option is not needed:
            gmail, outlook, qqmail
        For other email providers, you have to specify them manually, or
        modify this script.
    -p: Imap port, default is 993
    -P: Imap password. If not provided, the output of this command is used:
            pass show mail/<email>
    -n: Output the latest N emails' info (date, subject, from one in each line)
EOF
}

# Minimal time interval between two imap queries
query_interval=120

# CLI arguments
while getopts hn:s:p:P: param; do
    case "$param" in
        s) arg_server=$OPTARG;;
        p) arg_port=$OPTARG;;
        P) arg_password=$OPTARG;;
        n) arg_number=$OPTARG;;
        h|*) usage; exit;;
    esac
done
shift $((OPTIND - 1))

# Get the email
if [ $# = 1 ]; then email=$1; else usage; exit 1; fi

# Some predefined server and ports
case "${email##*@}" in
    outlook.com) server=imap-mail.outlook.com ;;
    qq.com)      server=imap.qq.com ;;
    gmail)       server=imap.gmail.com ;;
    *) ;;
esac

# CLI arguments take precedence
port=${arg_port:-993}
server=${arg_server:-$server}
[ -z "$server" ] && { echo Server not set. >&2; exit 1; }

# Read possible cached results
time_now="$(date +%s)"
tempfile="/tmp/imap_$email"
[ -f "$tempfile" ] && read -r time_last count < "$tempfile"
# TODO: -n N option not working here
if [ -n "$count" ] && [ -n "$time_last" ] \
&& [ $((time_now - time_last)) -lt "$query_interval" ]; then
    echo "$count"; exit
fi

# Password operations are slow, put it after using cached results above
password=$(pass show mail/"$email" 2> /dev/null)
password=${arg_password:-$password}
[ -z "$password" ] && { echo Password not set. >&2; exit 1; }

# Fetch and cache
unseen=$(curl --fail --silent --max-time 30 --connect-timeout 30 \
              --user "$email:$password" \
              --url "imaps://$server:$port/INBOX" \
              --request "UID SEARCH UNSEEN" || exit)
unseen=$(echo "$unseen" | cut -d " " -f 3- | tr -d "\r")
count=$(echo "$unseen" | wc -w)
echo "$time_now $count" > "$tempfile"

# Output
echo "$count"

# fetch email envelope
base64_decode() {
    encode=${1%\?*}; base64=${1#*\?}; string=$2
    if [ "$base64" = 'B' ] || [ "$base64" = 'b' ]; then
        echo "$string" | base64 -d | iconv -f "$encode" -t "utf-8"
    fi
}

parse_envelope() {
    # https://tools.ietf.org/html/rfc3501#section-7.4.2 FETCH Response
    base64_regex='\"=?\([^?]*?.\)?\([^?]*\)?=\"' # contains 2 matches
    quoted_regex='\"\([^\"]*\)\"' # contains 1 match
    while IFS=\| read -r date subject_enc subject from_enc from user host; do
        date -d "$date" +"%Y-%m-%d %r"
        base64_decode "$subject_enc" "$subject"; echo
        base64_decode "$from_enc" "$from"
        echo " <$user@$host>"
    done << EOF
    $(sed "s/\* [0-9]* FETCH (UID [0-9]* ENVELOPE ($quoted_regex $base64_regex (($base64_regex NIL $quoted_regex $quoted_regex)).*))/\1|\2|\3|\4|\5|\6|\7/" | tr -d '\r')
EOF
}

if [ -n "$_number" ] && [ "$count" -gt 0 ]; then
    [ "$count" -ge "$_number" ] && start_pos=$((count - _number + 1))
    uids="$(echo "$unseen" | cut -d " " -f ${start_pos:-1}- | tr " " ",")"
    curl -f -s -m 30 --connect-timeout 30 -u "$email:$password" \
        --url "imaps://$server:$port/INBOX" -X "UID FETCH $uids (ENVELOPE)" \
    | parse_envelope
fi
