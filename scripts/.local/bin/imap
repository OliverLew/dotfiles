#!/bin/sh
# Reference: https://tools.ietf.org/html/rfc5092

usage()
{
    cat >&2 << EOF
Usage: $(basename "$0") [-s server] [-p port] [-P password] [-n N] [-h] email

Options:
    -s: Server address of email provider. For the following email providers this
        option is not needed: gmail, outlook, qqmail
    -p: Imap port, default is 993
    -P: Imap password. If not provided, the output of this command is used:
            pass show mail/<email>
    -n: Output the latest N emails' info (date, subject, from one in each line)
EOF
}

while getopts hn:s:p:P: param; do
    case "$param" in
        s) _server=$OPTARG;;
        p) _port=$OPTARG;;
        P) _password=$OPTARG;;
        n) _number=$OPTARG;;
        h|*) usage; exit;;
    esac
done
shift $((OPTIND - 1))

# Get the email
if [ $# = 1 ]; then email=$1; else usage; exit 1; fi

# Some predefined server and ports
port=993
case "${email##*@}" in
    outlook.com) server=imap-mail.outlook.com ;;
    qq.com)      server=imap.qq.com ;;
    gmail)       server=imap.gmail.com ;;
    *) ;;
esac

# CLI arguments take precedence
[ -n "$_server" ] && server="$_server"
[ -n "$_port" ] && port="$_port"

[ -z "$server" ] && { echo Server not set. >&2; exit 1; }
[ -z "$port" ] && { echo Port not set. >&2; exit 1; }

# Minimal time interval between two imap queries
query_interval=60

tempfile="/tmp/imap_$email"
touch "$tempfile"
read -r time_last count < "$tempfile"
time_now="$(date +%s)"
# TODO: -n N option not working here
if [ -n "$count" ] && [ $((time_now - time_last)) -lt "$query_interval" ]; then
    echo "$count"; exit
fi

# Password operations are slow, put it after using cached results above
password=$(pass show mail/"$email" 2> /dev/null)
[ -n "$_password" ] && password="$_password"
[ -z "$password" ] && { echo Password not set. >&2; exit 1; }

unseen=$(curl -f -s --max-time 30 --connect-timeout 30 --user "$email:$password" \
         --url "imaps://$server:$port/INBOX" --request "UID SEARCH UNSEEN" || exit)
unseen=$(echo "$unseen" | cut -d " " -f 3- | tr -d "\r")
count=$(echo "$unseen" | wc -w)
echo "$time_now $count" > "$tempfile"

echo "$count"

# fetch email envelope

base64_decode() {
    encode=${1%\?*}; base64=${1#*\?}; string=$2
    if [ "$base64" = 'B' ] || [ "$base64" = 'b' ]; then
        echo "$string" | base64 -d | iconv -f "$encode" -t "utf-8"
    fi
}

parse_envelope() {
    base64_regex='\"=?\([^?]*?.\)?\([^?]*\)?=\"' # contains 2 matches
    quoted_regex='\"\([^\"]*\)\"' # contains 1 match
    while IFS=\| read -r date subject_enc subject from_enc from user host; do
        date -d "$date" +"%Y-%m-%d %r"
        base64_decode "$subject_enc" "$subject"; echo
        base64_decode "$from_enc" "$from"
        echo " $user@$host"
    done << EOF
    $(sed "s/\* [0-9]* FETCH (UID [0-9]* ENVELOPE ($quoted_regex $base64_regex (($base64_regex NIL $quoted_regex $quoted_regex)).*))/\1|\2|\3|\4|\5|\6|\7/")
EOF
}

if [ -n "$_number" ] && [ "$count" -gt 0 ]; then
    [ "$count" -ge "$_number" ] && start_pos=$((count - _number + 1))
    query_list="$(echo "$unseen" | cut -d " " -f ${start_pos:-1}- | tr " " ",")"
    # https://tools.ietf.org/html/rfc3501#section-7.4.2 FETCH Response
    curl -f -s --max-time 30 --connect-timeout 30 --user "$email:$password" \
        --url "imaps://$server:$port/INBOX" -X "UID FETCH $query_list (ENVELOPE)" \
    | parse_envelope
fi
